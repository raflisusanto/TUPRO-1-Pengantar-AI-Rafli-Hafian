# -*- coding: utf-8 -*-
"""TUGAS PEMROGRAMAN PENGANTAR AI - Rafli & Hafian.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1z1iWUm35AxnfXaJZiUd_Aj9WjsPW_LFn

# TUGAS PEMROGRAMAN PENGANTAR AI - Implementasi Genetic Algorithm
Muhamad Rafli Susanto - 1301204052 <br>
Hafian Fathul Madani - 1301204116

![unknownzzzzz.png](data:image/png;base64,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)

Mencari nilai x dan y dengan genetic algorithm agar fungsi diatas bisa menghasilkan nilai minimum
"""

# Untuk fungsi math
import math

# Untuk men-randomize
import random

# Initialize Population
def inisialisasiPopulasi(jumlahKromosom):
  populasi = []
  for kromosom in range(jumlahKromosom):
    populasi.append([random.randrange(0,9) for i in range(6)])
  return populasi

# Fungsi matematika
def fungsiMath(x, y):
  hasil = ((math.cos(x) + math.sin(y))**2)/((x**2)+(y**2))
  return hasil

# 1 Kromosom = 6 Gen; n = 3 gen
def repInteger(kromosom, ra, rb, n):
    ''' Men-Decode sebuah representasi Integer ke bilangan Real dengan 
    batas bawah ra, batas atas rb, dan jumlah gen n'''
    # Pecah list kromosom jadi dua untuk x (index 0-2) dan y (index 3-5)
    kromosomListX = [kromosom[i] for i in range(3)]
    kromosomListY = [kromosom[i] for i in range(3, len(kromosom))]

    num = ra-rb
    denum = sum([9*(10**-i) for i in range(1, n+1)])

    # Untuk masukin ke rumus X
    multX = sum([kromosomListX[i-1]*(10**-i) for i in range(1, n+1)])
    # Untuk masukin ke rumus Y
    multY = sum([kromosomListY[i-1]*(10**-i) for i in range(1, n+1)])

    x = rb + ((num/denum) * multX)
    y = rb + ((num/denum) * multY)

    # return [x,y] dalam real
    return [x, y]

# Fungsi fitness minimasi
def fitnessFunct(decode):
    cek = fungsiMath(decode[0], decode[1])
    # mengecek apakah minimasi(hasil=0) atau tidak
    if cek == 0:
      return 9999999999999999999
    else:
      return 1/cek

def rouletteWheel(sortedPopulasi, populasi, totalFitness):
    ''' Mengambil pair of parents dari populasi untuk di crossOver (harus beda-beda)
        fungsi untuk memilih orang tua dengan metode roulette wheel
    '''        
    # Menghitung probabilitas terambilnya sebuah kromosom berdasarkan fitnessnya
    # dan langsung memilihnya jika lebih besar dari random.uniform(0, 1)
    idxOrtu = -1
    for kromosom in range(len(sortedPopulasi)):
      if random.uniform(0, 1) <= (sortedPopulasi[kromosom][2]/totalFitness):
        idxOrtu = kromosom
        break
    return populasi[idxOrtu]

def sumFitness(sortedPopulasi):
  # Mencari sum fitness dari populasi untuk dipakai di roulette wheel
  totalFitness = 0
  for i in range(len(sortedPopulasi)):
      totalFitness = totalFitness + sortedPopulasi[i][2]
  return totalFitness

# Metode Crossover (pilih)
def crossOver(ortuA, ortuB, probCrossOver):
    """
    fungsi untuk melakukan rekombinasi satu titik (1-point crossover) dengan
    probabilitas tertentu
    """
    # probCrossOver = probabilitas crossover
    offSpringA = ortuA
    offSpringB = ortuB
    if random.uniform(0, 1) <= probCrossOver:
      # Generate titik potong
      tiPot = random.randint(1, 5)
      # Crossover
      for i in range(tiPot):
        temp = ortuA[i]
        offSpringA[i] = offSpringB[i]
        offSpringB[i] = temp
    return offSpringA, offSpringB

# Metode mutasi membalik nilai integer
def mutasiInteger(kromosom, probMutate):
  ''' Mutasi Kromosom dengan Representasi Integer dengan metode membalik nilai integer '''
  # probMutate = probabilitas mutasi
  if random.uniform(0, 1) <= probMutate:
    randomIndex = random.randrange(0, 5)
    kromosom[randomIndex] = 9 - kromosom[randomIndex]
  return kromosom

# Seleksi survivor; dari parents elite ada 2; sisanya diambil dari populasi anak
def elitism(populasiOrtu):
  ''' Mengambil dua kromosom dengan nilai fitness terbesar dari populasi orang tua yang sudah di sort '''
  # Ambil kromosom nya saja
  return populasiOrtu[0][0], populasiOrtu[1][0]

def seleksiSurvivor(jumlahKromosom, populasiAnak, elite1, elite2):
  ''' Menghasilkan populasi baru untuk generasi berikutnya '''
  populasiBaru = []

  populasiBaru.append(list(elite1))
  populasiBaru.append(list(elite2))

  for kromosom in range(0, jumlahKromosom-2):
    # Ambil kromosom nya saja
    populasiBaru.append(populasiAnak[kromosom])
  return populasiBaru

def GeneticAlgorithmV1(jumlahGenerasi, jumlahKromosom, probCross, probMutasi, batasBawahXY, batasAtasXY, populasiBaru):
  ''' Procedure genetic algorithm untuk mencari nilai minimum pada fungsiMath(x, y) 
      Procedure ini akan men-generate generasi berdasarkan jumlahGenerasi
  '''
  for generations in range(jumlahGenerasi):
    rankedPopulasi = []
    populasi = []
    for kromosom in populasiBaru:
      # Decode Kromosom
      decode = repInteger(kromosom, batasBawahXY, batasAtasXY, 3)

      # Append ke list rankedPopulasi (ada kromosom, ada hasil decode, dan fitnessnya)
      rankedPopulasi.append([tuple(kromosom), decode, fitnessFunct(decode)])

    # Sort berdasarkan fitness
    rankedPopulasi.sort(key = lambda x: x[2], reverse = True)
    populasi = [tuple(rankedPopulasi[i][0]) for i in range(len(rankedPopulasi))]

    # Ambil elite dari populasi
    eliteA, eliteB = elitism(rankedPopulasi)
    eliteA = tuple(eliteA)
    eliteB = tuple(eliteB)

    # Print solusi terbaik per generasi
    bestCandidate = rankedPopulasi[0]
    print("=== Solusi terbaik di generasi ke-{} ===".format(generations+1))
    print("Kromosom |   {}  |".format(bestCandidate[0]))
    print("X        | {:20}  |".format(bestCandidate[1][0]))
    print("Y        | {:20}  |".format(bestCandidate[1][1]))
    print("Fitness  | {:20}  |".format(bestCandidate[2]))
    print("Hasil    | {:20.15f}  |".format(fungsiMath(bestCandidate[1][0], bestCandidate[1][1])))
    print()


    ''' ================  Making new generation  ================ '''
    populasiBaru = []
    for _ in range((jumlahKromosom-2) // 2):
      offspring = []
      # Pilih Parent -> pilih ortuA dan ortuB dari rankedPopulasi (gabole sama)
      totalFitness = sumFitness(rankedPopulasi)

      a = list(rouletteWheel(rankedPopulasi, populasi, totalFitness))
      b = list(rouletteWheel(rankedPopulasi, populasi, totalFitness))

      while a == b:
        b = list(rouletteWheel(rankedPopulasi, populasi, totalFitness))

      offspring.append(a)
      offspring.append(b)

      # Crossover -> Output 2 kromosom baru [krom1], [krom2]
      offspring[0], offspring[1] = crossOver(offspring[0], offspring[1], probCross)
      
      # Mutasi -> Output masing2 kromosom baru [krom1] dan [krom2]
      offspring[0] = mutasiInteger(offspring[0], probMutasi)
      offspring[1] = mutasiInteger(offspring[1], probMutasi)

      # Menambahkan kromosom yang sudah di crossover dan mutasi ke keturunan baru
      populasiBaru.append(offspring[0])
      populasiBaru.append(offspring[1])

    # Seleksi
    populasiBaru = seleksiSurvivor(jumlahKromosom, populasiBaru, eliteA, eliteB)

def GeneticAlgorithmV2(fitnessTarget, jumlahKromosom, probCross, probMutasi, batasBawahXY, batasAtasXY, populasiBaru):
  ''' Procedure genetic algorithm untuk mencari nilai minimum pada fungsiMath(x, y) 
      Procedure ini akan men-generate generasi terus menerus sampai fitnessTarget tercapai
  '''
  bestFitness = 0
  n = 0
  while bestFitness < fitnessTarget:
    rankedPopulasi = []
    populasi = []
    n += 1
    for kromosom in populasiBaru:
      # Decode Kromosom
      decode = repInteger(kromosom, batasBawahXY, batasAtasXY, 3)

      # Append ke list rankedPopulasi (ada kromosom, ada hasil decode, dan fitnessnya)
      rankedPopulasi.append([tuple(kromosom), decode, fitnessFunct(decode)])

    # Sort berdasarkan fitness
    rankedPopulasi.sort(key = lambda x: x[2], reverse = True)
    populasi = [tuple(rankedPopulasi[i][0]) for i in range(len(rankedPopulasi))]

    # Ambil elite dari populasi
    eliteA, eliteB = elitism(rankedPopulasi)
    eliteA = tuple(eliteA)
    eliteB = tuple(eliteB)

    # Print solusi terbaik per generasi
    bestCandidate = rankedPopulasi[0]
    bestFitness = bestCandidate[2]
    print("=== Solusi terbaik di generasi ke-{} ===".format(n))
    print("Kromosom |   {}  |".format(bestCandidate[0]))
    print("X        | {:20}  |".format(bestCandidate[1][0]))
    print("Y        | {:20}  |".format(bestCandidate[1][1]))
    print("Fitness  | {:20}  |".format(bestCandidate[2]))
    print("Hasil    | {:20.15f}  |".format(fungsiMath(bestCandidate[1][0], bestCandidate[1][1])))
    print()


    ''' ================  Making new generation  ================ '''
    populasiBaru = []
    for _ in range((jumlahKromosom-2) // 2):
      offspring = []
      # Pilih Parent -> pilih ortuA dan ortuB dari rankedPopulasi (gabole sama)
      totalFitness = sumFitness(rankedPopulasi)

      a = list(rouletteWheel(rankedPopulasi, populasi, totalFitness))
      b = list(rouletteWheel(rankedPopulasi, populasi, totalFitness))

      while a == b:
        b = list(rouletteWheel(rankedPopulasi, populasi, totalFitness))

      offspring.append(a)
      offspring.append(b)

      # Crossover -> Output 2 kromosom baru [krom1], [krom2]
      offspring[0], offspring[1] = crossOver(offspring[0], offspring[1], probCross)
      
      # Mutasi -> Output masing2 kromosom baru [krom1] dan [krom2]
      offspring[0] = mutasiInteger(offspring[0], probMutasi)
      offspring[1] = mutasiInteger(offspring[1], probMutasi)

      # Menambahkan kromosom yang sudah di crossover dan mutasi ke keturunan baru
      populasiBaru.append(offspring[0])
      populasiBaru.append(offspring[1])

    # Seleksi
    populasiBaru = seleksiSurvivor(jumlahKromosom, populasiBaru, eliteA, eliteB)

# Main GA Program
totalGenerasi = 100
totalKromosom = 100
pc = 1.0
pm = 1.0
batasBawahXY = -5
batasAtasXY = 5
initPopulasi = inisialisasiPopulasi(totalKromosom)

# Berdasarkan total generasi
GeneticAlgorithmV1(totalGenerasi, totalKromosom, pc, pm, batasBawahXY, batasAtasXY, initPopulasi)

# Berdasarkan target fitness
# targetFitness = 999999
# GeneticAlgorithmV2(targetFitness, totalKromosom, pc, pm, batasBawahXY, batasAtasXY, initPopulasi)